# 重要论文：Codd 与关系模型

*2017 年 12 月 29 日*

如今可能难以置信，但关系型数据库 (relational database) 曾是技术领域的新宠儿。在 2017 年，关系模型 (relational model) 正与各种前沿的 NoSQL 技术竞争，这使得关系型数据库系统看起来有些过时和乏味。然而，50 年前，主流的数据库系统没有一个是关系型的。当时没有人想到以这种方式来组织数据。当关系模型横空出世时，它是一个彻底的创新理念，彻底改变了数据库领域，并催生了一个价值数十亿美元的产业。

关系模型于 1970 年问世。IBM 的研究员 Edgar F. Codd 发表了一篇题为《大型共享数据库的关系数据模型》的论文。这篇论文是他一年前在 IBM 内部传阅的一篇论文的重写版本。这篇论文显得很谦逊；Codd 并没有在摘要中宣称他发现了一种存储数据的绝妙新方法。他只是声称运用了一种新颖的工具（数学上的“关系”概念）来解决当时主流数据库模型的一些不足。

1970 年，关于如何构建数据库主要有两种主流思想：层次模型 (hierarchical model) 和网状模型 (network model)。层次模型被 IBM 的信息管理系统 (Information Management System, IMS) 所采用，IMS 是当时占据主导地位的数据库系统。网状模型则由一个名为 CODASYL 的标准委员会（顺便提一句，该委员会也制定了 COBOL 语言标准）制定，并由其他几家数据库系统供应商实现。这两种模型实际上并没有太大区别；它们都可以被称为“导航式”模型。它们通过使用指针来维护数据之间的链接，将树状或图状数据结构持久化到磁盘上。检索存储在树底部的记录，需要首先遍历其所有祖先记录。这些数据库速度很快（IMS 至今仍被许多金融机构使用，部分原因就在于此，参见这篇优秀的博客文章）但缺乏灵活性。对于那些突然需要查询树底部记录，却又没有明确起点可供导航的数据库管理员来说，这无疑是个巨大的麻烦。

Codd 认为这种不灵活性是一个更大问题的症结所在。使用层次或网状数据库的程序必须了解存储数据的结构。程序之所以必须了解这些，是因为它们负责沿着这种结构进行导航，以找到所需的信息。这一点非常真实，以至于当网状模型的主要先驱 Charles Bachman 在 1973 年因其工作获得图灵奖 (Turing Award) 时，他发表了一篇题为《程序员即导航员》的演讲。当然，如果程序背负着这样的责任，那么一旦数据库结构发生变化，它们就会立即崩溃。在 1970 年的论文引言中，Codd 阐述了寻找更好模型的动机，他认为我们需要“数据独立性 (data independence)”，并将其定义为“应用程序和终端活动不受数据类型增长和数据表示变化的影响”。他认为，关系模型“在多个方面似乎优于当前流行的图模型或网状模型”，部分原因在于，除了其他优点之外，关系模型“提供了一种仅用其自然结构描述数据的方法”。他的意思是，程序可以安全地忽略为了存储和检索目的而强加给数据的任何人工结构（如树状结构）。

为了进一步阐明导航式模型的问题，Codd 在论文的第一部分专门用一个涉及机器零件和装配项目的示例数据集进行说明。他说，这个数据集在现有系统中至少可以用五种不同的方式表示。任何假设其中一种结构而开发的程序 \\(P\\)，在针对其他至少三种结构运行时都会失败。程序 \\(P\\) 也可以尝试提前判断它可能处理的是哪种结构，但这在特定情况下很难做到，在一般情况下则几乎不可能。因此，只要程序需要了解数据的结构，我们就无法在不破坏程序的情况下切换到替代结构。这确实是个大问题，因为（引自摘要）“由于查询、更新和报告流量的变化以及存储信息类型的自然增长，数据表示形式的改变将经常是必要的。”

接着，Codd 介绍了他的关系模型。这一模型在后续论文中得到了完善和扩展：1971 年，Codd 撰写了关于他创建的类似 SQL 的查询语言 ALPHA 的文章；在另一篇 1971 年的论文中，他引入了我们今天熟知并喜爱的最初三种范式 (normal forms)；1972 年，他进一步发展了关系代数 (relational algebra) 和关系演算 (relational calculus)，这些都是关系模型严谨的数学基础。但 Codd 1970 年的论文包含了关系思想的核心：

> “关系”一词在此处沿用其公认的数学含义。给定集合 \\(S\_1, S\_i, ..., S\_n\\)（不必互不相同），如果 \\(R\\) 是一个由 \\(n\\) 元组构成的集合，其中每个 \\(n\\) 元组的第一个元素来自 \\(S\_1\\)，第二个元素来自 \\(S\_2\\)，依此类推，则 \\(R\\) 是这些 \\(n\\) 个集合上的一个关系。我们将 \\(S\_j\\) 称为 \\(R\\) 的第 \\(j\\) 个“域 (domain)”。如上所述，\\(R\\) 被称为具有 \\(n\\) 的“度 (degree)”。度为 1 的关系通常称为“一元关系 (unary)”，度为 2 的称为“二元关系 (binary)”，度为 3 的称为“三元关系 (ternary)”，度为 \\(n\\) 的称为“n 元关系 (n-ary)”。

如今，我们称“关系 (relation)”为“表 (table)”，称“域 (domain)”为“属性 (attribute)”或“列 (column)”。论文中实际上没有出现“表”这个词，尽管 Codd 对关系的视觉表示（他称之为“数组”）确实类似于表。Codd 还定义了其他几个术语，其中一些我们沿用至今，另一些则已被替换。他解释了主键 (primary key) 和外键 (foreign key)，以及他所称的“活跃域 (active domain)”，即给定域或列中实际出现的所有不同值的集合。接着，他花了一些时间区分“简单域 (simple domain)”和“非简单域 (nonsimple domain)”。简单域包含“原子 (atomic)”或“不可分解 (nondecomposable)”的值，例如整数。非简单域则以关系作为其元素。Codd 在这里给出的例子是员工的薪资历史。薪资历史不是一个单一的薪资，而是一系列与日期关联的薪资集合。因此，薪资历史不能用一个单一的数字或字符串来表示。

如何将非简单域存储在多维数组（也就是表）中，这并非显而易见。人们可能会倾向于使用某种指针来表示非简单关系，但那样我们就会重蹈导航式模型的覆辙。相反，Codd 引入了范式化 (normalization)，至少在 1970 年的论文中，这仅仅意味着将非简单域转换为简单域。做法是扩展子关系，使其包含父关系的主键。子关系的每个元组 (tuple) 都使用简单域来引用其父关系，从而消除了父关系中对非简单域的需求。范式化意味着无需指针，从而避开了指针在导航式模型中造成的所有问题。

读到这里，任何阅读 Codd 论文的人都会产生一些疑问，比如“好的，我该如何实际查询这样的系统呢？”Codd 提到了创建一种通用子语言的可能性，用于从其他程序查询关系型数据库，但他在这篇特定论文中没有定义这种语言。他确实用数学术语解释了这种语言必须支持的许多基本操作，例如连接 (joins)、“投影 (projection)”（在 SQL 中是 `SELECT`）和“限制 (restriction)”（在 SQL 中是 `WHERE`）。Codd 1970 年论文的惊人之处在于，所有核心思想都已包含其中——我们编写 `SELECT` 语句和连接操作已经将近半个世纪了。

Codd 在论文的最后讨论了范式化的关系型数据库除了其他优点之外，如何减少数据存储中的冗余并提高一致性。总而言之，这篇论文只有 11 页，阅读起来并不困难。我鼓励你自己去阅读一下。Codd 的思想又过了十年才在一个可运行的系统中得到妥善实现，但当它们最终实现时，这些系统明显优于之前的系统，以至于它们迅速风靡全球。

*如果您喜欢这篇文章，每四周都会有更多类似内容发布！请在 Twitter 上关注 [@TwoBitHistory](https://twitter.com/TwoBitHistory) 或订阅 [RSS 源](https://twobithistory.org/feed.xml)，确保您不会错过新文章。*