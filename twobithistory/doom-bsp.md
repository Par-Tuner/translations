# 《毁灭战士》中采用二叉空间分割是天才之举吗？

*2019 年 11 月 6 日*

1993 年，id Software 发布了第一人称射击游戏 (first-person shooter) 《毁灭战士》(Doom)，它迅速成为一种现象。这款游戏现在被认为是史上最具影响力的游戏之一。

《毁灭战士》发布十年后，即 2003 年，记者 David Kushner 出版了一本关于 id Software 的书，名为《毁灭战士大师》(Masters of Doom)，这本书后来成为《毁灭战士》创作的权威记述。我几年前读过《毁灭战士大师》，现在记不太清了，但书中有一个关于首席程序员 John Carmack 的故事一直让我印象深刻。这是一个大致的概述 (完整细节见下文)，但本质上，在《毁灭战士》开发的早期，Carmack 意识到他为游戏编写的 3D 渲染器 (3D renderer) 在尝试渲染某些关卡时会变得非常慢。这是不可接受的，因为《毁灭战士》本应是充满动作和狂热的游戏。因此，Carmack 意识到他的渲染器存在根本性问题，需要找到更好的渲染算法 (rendering algorithm)，于是他开始阅读研究论文。他最终实现了一种名为“二叉空间分割 (Binary Space Partitioning)”的技术，这种技术以前从未在视频游戏中使用过，它极大地加快了《毁灭战士》引擎的速度。

Carmack 将前沿学术研究应用于视频游戏的故事一直让我印象深刻。这是我对 Carmack 成为传奇人物的原因的解释。他理应因各种原因被称为典型的天才视频游戏程序员，但这次与学术论文和二叉空间分割相关的事件是我首先想到的理由。

显然，这个故事令人印象深刻，因为“二叉空间分割”听起来就像是一件很难仅仅通过阅读就能自己实现的事情。我一直认为 Carmack 所做的是一个巧妙的智力飞跃，但由于我从未真正理解二叉空间分割是什么，或者当 Carmack 决定使用它时，这项技术有多么新颖，所以我一直无法确定。从 Homer Simpson 到 Albert Einstein 的光谱来看，Carmack 将二叉空间分割添加到《毁灭战士》中，这究竟是多大程度的天才之举呢？

我还想知道二叉空间分割最初是从哪里来的，以及这个想法是如何传到 Carmack 那里的。所以这篇文章是关于 John Carmack 和《毁灭战士》的，但它也关乎一种数据结构的历史：二叉空间分割树 (Binary Space Partitioning tree，简称 BSP 树)。事实证明，BSP 树，非常有趣地，就像计算机科学中的许多事物一样，起源于为军事目的进行的研究。

没错：《毁灭战士》的第一个关卡 E1M1，是由美国空军带来的。

## 可见表面判定问题

BSP 树是计算机图形学中最棘手的问题之一的解决方案。为了渲染一个三维场景，渲染器必须根据特定的视点，判断哪些物体可见，哪些不可见。如果你有充足的时间，这并不是特别困难，但一个合格的实时游戏引擎需要每秒至少 30 次地判断哪些物体可见，哪些不可见。

这个问题有时被称为可见表面判定 (Visible Surface Determination) 问题。Michael Abrash 是一位与 Carmack 合作开发《雷神之锤》(Quake，id Software 继《毁灭战士》之后的又一力作) 的程序员，他在其著名的《图形编程黑皮书》(Graphics Programming Black Book) 中写到了 VSD 问题：

> 我想谈谈在我看来最棘手的 3D 问题：可见表面判定 (在每个像素上绘制正确的表面)，以及它的近亲，剔除 (culling) (尽可能快地丢弃不可见的多边形，这是一种加速可见表面判定的方法)。为简洁起见，从现在起我将使用缩写 VSD 来表示可见表面判定和剔除。

> 为什么我认为 VSD 是最严峻的 3D 挑战？尽管光栅化 (rasterization) 问题，例如纹理映射 (texture mapping)，引人入胜且至关重要，但它们的范围相对有限，并且随着 3D 加速器的出现正逐渐被硬件处理；此外，它们只随着屏幕分辨率的提高而扩展，而屏幕分辨率的提高相对适度。

> 相比之下，VSD 是一个开放性问题，目前有数十种方法在使用。更重要的是，如果以不复杂的方式进行 VSD，其性能会直接随场景复杂性而扩展，而场景复杂性往往以平方或立方函数增长，因此这很快就会成为渲染真实世界的限制因素 [^1]。

Abrash 在 90 年代末撰写了关于 VSD 问题难度的文章，那时《毁灭战士》已经证明普通人希望能在家用电脑上玩图形密集型游戏。在 90 年代初，当 id Software 首次开始发布游戏时，游戏必须被编程为能在并非为此设计的电脑上高效运行，这些电脑主要用于文字处理、电子表格应用程序，以及其他一些小功能。为了实现这一点，特别是对于 id Software 在《毁灭战士》之前发布的少数 3D 游戏，id Software 必须发挥创造力。在这些游戏中，所有关卡的设计都受到了限制，从而使 VSD 问题更容易解决。

例如，在 id Software 在《毁灭战士》之前发布的《德军总部 3D》(Wolfenstein 3D) 中，每个关卡都由轴对齐的墙壁构成。换句话说，在《德军总部》的世界里，你只能有南北向或东西向的墙壁，没有其他方向。墙壁也只能以固定的间隔放置在网格上——所有走廊要么是一个网格方块宽，要么是两个网格方块宽，等等，但绝不会是 2.5 个网格方块宽。尽管这意味着 id Software 团队只能设计出看起来有些相似的关卡，但这大大简化了 Carmack 为《德军总部》编写渲染器的工作。

《德军总部》的渲染器通过从屏幕向虚拟世界“行进”光线来解决 VSD 问题。通常，使用光线的渲染器是光线投射渲染器 (raycasting renderer)——这些渲染器通常很慢，因为在光线投射器中解决 VSD 问题涉及找到光线与世界中某个物体之间的第一个交点，这在一般情况下需要大量的数值计算。但在《德军总部》中，由于所有墙壁都与网格对齐，光线可能与墙壁相交的唯一位置就是网格线。因此，渲染器只需检查每个交点。如果渲染器从检查离玩家视点最近的交点开始，然后检查下一个最近的，依此类推，并在遇到第一堵墙时停止，那么 VSD 问题就以一种几乎微不足道的方式解决了。光线只是从每个像素向前行进，直到它碰到某个物体，之所以可行是因为这种行进在 CPU 周期方面非常廉价。实际上，由于所有墙壁的高度都相同，因此只需为每个像素*列*行进一条光线。

这种渲染捷径使得《德军总部》在没有专用显卡的时代，也能在性能不足的家用电脑上流畅运行。但这种方法不适用于《毁灭战士》，因为 id 团队决定他们的新游戏将包含对角线墙壁、楼梯和不同高度的天花板等新颖元素。光线行进不再可行，因此 Carmack 编写了另一种渲染器。《德军总部》的渲染器为每个像素列投射一条光线，是一种“图像优先渲染器 (image-first renderer)”，而《毁灭战士》的渲染器则是一种“物体优先渲染器 (object-first renderer)”。这意味着《毁灭战士》的渲染器不是遍历屏幕上的像素并确定它们的颜色，而是遍历场景中的物体，并依次将每个物体投影到屏幕上。

在物体优先渲染器中，解决 VSD 问题的简单方法之一是使用 Z 缓冲区 (z-buffer)。每次将物体投影到屏幕上时，对于要绘制的每个像素，都会进行一次检查。如果物体要绘制的部分比该像素上已绘制的内容更靠近玩家，那么就可以覆盖现有内容。否则，必须保持像素不变。这种方法很简单，但 Z 缓冲区需要大量内存，而且渲染器可能仍然会花费大量 CPU 周期来投影玩家永远看不到的关卡几何体。

在 20 世纪 90 年代早期，Z 缓冲区方法还有一个额外的缺点：在使用名为 VGA (Video Graphics Array) 视频适配器系统的 IBM 兼容 PC 上，写入输出帧缓冲区 (frame buffer) 是一项昂贵的操作。因此，绘制那些稍后会被覆盖的像素所花费的时间会严重拖累渲染器的性能。

由于写入帧缓冲区非常昂贵，理想的渲染器是那种从绘制离玩家最近的物体开始，然后是紧随其后的物体，依此类推，直到屏幕上的每个像素都被写入。此时，渲染器就会知道停止，从而节省了考虑玩家看不到的远距离物体可能花费的所有时间。但是，以这种方式对场景中的物体进行排序，从最近到最远，等同于解决了 VSD 问题。问题再次回到：玩家能看到什么？

最初，Carmack 试图通过依赖《毁灭战士》关卡的布局来解决这个问题。他的渲染器首先绘制玩家当前所在房间的墙壁，然后“泛洪”到相邻房间，绘制从当前房间可见的那些房间的墙壁。只要每个房间都是凸的，这就能解决 VSD 问题。非凸的房间可以被分割成凸的“扇区”。你可以通过 [这个视频](https://youtu.be/HQYsFshbkYw?t=822) 看到这种渲染技术在极慢速度下可能是什么样子，YouTuber Bisqwit 在其中展示了他自己的一个渲染器，该渲染器按照相同的通用算法工作。这个算法在《毁灭公爵 3D》(Duke Nukem 3D) 中成功使用，该游戏在《毁灭战士》发布三年后推出，当时 CPU 更强大。但是，在 1993 年，运行在当时可用的硬件上，《毁灭战士》使用这种算法的渲染器在处理复杂关卡时遇到了困难——特别是当扇区相互嵌套时，这是创建像圆形楼梯坑这样的唯一方法。圆形楼梯坑导致了大量重复的递归下降到已经绘制过的扇区中，从而扼杀了游戏引擎的速度。

大约在 id 团队意识到《毁灭战士》游戏引擎可能太慢的时候，id Software 被要求将《德军总部 3D》移植到 Super Nintendo 上。Super Nintendo 比当时的 IBM 兼容 PC 性能更弱，结果发现，即使是简单的光线行进《德军总部》渲染器，在 Super Nintendo 硬件上也运行不够快。于是 Carmack 开始寻找更好的算法。实际上，Carmack 首次研究并实现二叉空间分割 (Binary Space Partitioning) 是为了《德军总部》的 Super Nintendo 移植版。在《德军总部》中，这相对简单，因为所有墙壁都是轴对齐的；而在《毁灭战士》中，它会更复杂。但 Carmack 意识到 BSP 树也能解决《毁灭战士》的速度问题。

## 二叉空间分割

二叉空间分割 (Binary Space Partitioning) 通过提前将 3D 场景分割成多个部分，使 VSD 问题更容易解决。目前，你只需要理解为什么分割场景很有用：如果你在场景中画一条线 (在 3D 中实际上是一个平面)，并且你知道玩家或摄像机视点在哪一边，那么你也知道线的另一边没有任何东西可以阻挡视点这边的物体。如果你多次重复这个过程，最终会得到一个被分割成许多部分的 3D 场景，这本身并不会比原始场景有所改进，但现在你对场景中不同部分如何相互遮挡有了更多的了解。

最早撰写关于这样分割 3D 场景的人是那些试图为美国空军确定计算机图形学是否足够先进以用于飞行模拟器的研究人员。他们在 1969 年发布了一份名为《将计算机生成图像应用于视觉模拟的研究》的报告，其中公布了他们的发现。报告得出结论，计算机图形学可以用于训练飞行员，但也警告说，VSD 问题会使实现变得复杂：

> 在图像的实时计算中，必须面对的最重要问题之一是优先级或隐藏线问题。在我们日常对周围环境的视觉感知中，这是一个自然界轻而易举就能解决的问题；一个不透明物体的点会遮挡所有位于同一视线方向上且更远的其他点。在计算机中，这项任务是艰巨的。在一般情况下，解决优先级所需的计算量随环境复杂性呈指数级增长，很快就会超过与寻找物体透视图像相关的计算负荷 [^2]。

这些研究人员提到的一种解决方案，据他们说，早先在 NASA 的一个项目中也使用过，它基于创建我将称之为“遮挡矩阵 (occlusion matrix)”的东西。研究人员指出，一个将场景一分为二的平面可以用来解决平面两侧物体之间的“任何优先级冲突”。通常你可能需要将这些平面明确地添加到你的场景中，但对于某些类型的几何体，你可以直接依赖你已有的物体的面。他们在下图的例子中给出说明，其中 \\(p\_1\\)、\\(p\_2\\) 和 \\(p\_3\\) 是分割平面。如果摄像机视点位于这些平面中某个平面的前方或“真实”一侧，那么 \\(p\_i\\) 的值为 1。该矩阵显示了基于三个分割平面和摄像机视点位置的三个物体之间的关系——如果物体 \\(a\_i\\) 遮挡了物体 \\(a\_j\\)，那么矩阵中的条目 \\(a\_{ij}\\) 将为 1。

![](https://twobithistory.org/images/matrix_figure.png)

研究人员提出，这个矩阵可以在硬件中实现，并每帧重新评估。基本上，这个矩阵将充当一个大型开关或一种预构建的 Z 缓冲区。当绘制给定物体时，如果该物体的列中存在 1 并且相应的行物体也在被绘制，那么该物体的部分将不会输出视频。

这种矩阵方法的主要缺点是，要表示一个包含 \\(n\\) 个物体的场景，你需要一个大小为 \\(n^2\\) 的矩阵。因此，研究人员继续探讨是否可以将遮挡矩阵表示为“优先级列表”，这样大小就只有 \\(n\\)，并且可以建立物体应该被绘制的顺序。他们立即指出，对于某些场景，例如上图所示的场景，无法进行排序 (因为存在遮挡循环)，因此他们花费大量时间阐述“正确”和“不正确”场景之间的数学区别。最终他们得出结论，至少对于“正确”场景——场景设计师应该很容易避免“不正确”情况——可以生成一个优先级列表。但他们将列表生成留作读者的练习。看来这项 1969 年研究的主要贡献是指出，至少在 *理论上*，应该可以使用分割平面来对场景中的物体进行渲染排序。

直到 1980 年，一篇题为《基于先验树结构的可见表面生成》的论文才展示了一个具体的算法来实现这一点。这篇 1980 年的论文由 Henry Fuchs、Zvi Kedem 和 Bruce Naylor 撰写，引入了 BSP 树。作者表示，他们的新颖数据结构是“十年前首次采用但由于一些困难而未被广泛利用的方法的替代解决方案”——这里指的是 1969 年空军研究中采用的方法 [^3]。BSP 树一旦构建完成，就可以很容易地用于为场景中的物体提供优先级排序。

Fuchs、Kedem 和 Naylor 对 BSP 树的工作原理给出了相当易懂的解释，但让我看看能否提供一个不那么正式但更简洁的解释。

首先，你选择场景中的一个多边形 (polygon)，并将其所在的平面作为你的分割平面。这个多边形也最终成为你树的根节点。场景中剩余的多边形将位于你的根分割平面的某一侧。位于平面“前方”或“前方”半空间 (half-space) 的多边形最终进入根节点的左子树，而位于平面“后方”或“后方”半空间的多边形则进入右子树。然后你递归地重复这个过程，从你的左子树和右子树中选择一个多边形作为它们各自半空间的新分割平面，这会生成更多的半空间和更多的子树。当你没有多边形时就停止。

假设你想从后到前 (back-to-front) 渲染场景中的几何体。(这被称为“画家算法 (painter’s algorithm)”，因为它意味着离摄像机较远的多边形会被离摄像机较近的多边形覆盖绘制，从而产生正确的渲染。) 要实现这一点，你所要做的就是对 BSP 树进行中序遍历 (in-order traversal)，其中首先渲染任何节点的左子树还是右子树的决定，取决于摄像机视点相对于与该节点关联的分割平面是位于前方半空间还是后方半空间。因此，在树的每个节点处，你首先渲染平面“远”侧的所有多边形，然后是分割平面中的多边形，然后是平面“近”侧的所有多边形——“远”和“近”是相对于摄像机视点而言的。这解决了 VSD 问题，因为正如我们前面几段所了解的，分割平面远侧的多边形不会阻挡近侧的任何物体。

以下图表展示了表示简单 2D 场景的 BSP 树的构建和遍历。在 2D 中，分割平面变成了分割线，但在更复杂的 3D 场景中，基本思想是相同的。

![](https://twobithistory.org/images/bsp.svg)
图 1: 第一步：沿墙壁 D 的根分割线将剩余几何体分成两组。

![](https://twobithistory.org/images/bsp1.svg)
图 2: 第二步：D 两侧的半空间再次被分割。墙壁 C 是其半空间中唯一的墙壁，因此无需分割。墙壁 B 在其半空间中形成新的分割线。墙壁 A 必须被分割成两堵墙，因为它穿过了分割线。

![](https://twobithistory.org/images/bsp2.svg)
图 3: 相对于右上角视点的墙壁从后到前 (back-to-front) 排序，这对于实现画家算法 (painter’s algorithm) 很有用。这只是对树进行中序遍历 (in-order traversal)。

BSP 树真正巧妙之处在于，Fuchs、Kedem 和 Naylor 多次强调，它只需要构建一次。这有些令人惊讶，但无论摄像机视点在哪里，同一个 BSP 树都可以用来渲染场景。只要场景中的多边形不移动，BSP 树就保持有效。这就是为什么 BSP 树对于实时渲染如此有用——构建树的所有繁重工作都可以在渲染之前完成，而不是在渲染过程中。

Fuchs、Kedem 和 Naylor 提到一个需要进一步探讨的问题是，如何构建一个“好”的 BSP 树。你的 BSP 树的质量将取决于你决定使用哪些多边形来建立你的分割平面。我之前跳过了这一点，但如果你使用一个与其他多边形相交的平面进行分割，那么为了使 BSP 算法工作，你必须将相交的多边形一分为二，以便一部分可以进入一个半空间，另一部分进入另一个半空间。如果这种情况经常发生，那么构建 BSP 树将大大增加场景中的多边形数量。

Bruce Naylor，1980 年论文的作者之一，后来在他的 1993 年论文《构建好的分割树》(Constructing Good Partitioning Trees) 中写到了这个问题。据 John Romero，Carmack 在 id Software 的联合创始人之一说，这篇论文是 Carmack 在尝试在《毁灭战士》中实现 BSP 树时阅读的论文之一 [^4]。

## 《毁灭战士》中的 BSP 树

回想一下，在《毁灭战士》渲染器的初稿中，Carmack 曾试图通过让渲染器从玩家当前房间“泛洪”到相邻房间来建立关卡几何体的渲染顺序。BSP 树是建立这种顺序的更好方法，因为它们避免了渲染器多次访问同一房间 (或扇区) 从而浪费 CPU 周期的问题。

在实践中，“将 BSP 树添加到《毁灭战士》”意味着在《毁灭战士》关卡编辑器 (level editor) 中添加一个 BSP 树生成器 (BSP tree generator)。当《毁灭战士》中的一个关卡完成时，会从关卡几何体生成一个 BSP 树。根据 Fabien Sanglard 的说法，生成过程对于单个关卡可能需要长达八秒，而对于原始《毁灭战士》中的所有关卡则需要 11 分钟 [^5]。生成过程之所以漫长，部分原因是 Carmack 的 BSP 生成算法尝试使用各种启发式算法 (heuristics) 来寻找一个“好”的 BSP 树。八秒的延迟在运行时是不可接受的，但如果离线完成，等待时间并不长，特别是考虑到 BSP 树为渲染器带来的性能提升。单个关卡生成的 BSP 树随后将作为关卡数据的一部分，在游戏启动时加载到内存中。

Carmack 对 1980 年论文中概述的 BSP 树算法进行了改进，因为一旦《毁灭战士》启动并将当前关卡的 BSP 树读入内存，渲染器就会使用 BSP 树从前到后 (front-to-back) 而不是从后到前 (back-to-front) 绘制物体。在 1980 年的论文中，Fuchs、Kedem 和 Naylor 展示了如何使用 BSP 树来实现从后到前的画家算法 (painter’s algorithm)，但画家算法涉及大量的重复绘制 (over-drawing)，这在 IBM 兼容 PC 上会非常昂贵。因此，《毁灭战士》渲染器转而从离玩家较近的几何体开始绘制，先绘制它们，然后再绘制较远的几何体。使用 BSP 树很容易实现这种反向排序，因为你只需在树的每个节点处做出相反的遍历决定即可。为了确保较远的几何体不会覆盖较近的几何体，《毁灭战士》渲染器使用了一种隐式 Z 缓冲区 (implicit z-buffer)，它在内存占用小得多的情况下提供了 Z 缓冲区的大部分优势。有一个数组用于跟踪水平方向的遮挡，另外两个数组用于跟踪屏幕顶部和底部的垂直方向遮挡。《毁灭战士》渲染器之所以可以不使用实际的 Z 缓冲区，是因为《毁灭战士》在技术上并非完全的 3D 游戏。这些更廉价的数据结构之所以有效，是因为《毁灭战士》中不会出现某些情况：水平遮挡数组有效是因为没有倾斜的墙壁，而垂直遮挡数组有效是因为没有墙壁会有，比如说，两个窗户，一个在另一个上面。

剩下的唯一一个棘手问题是如何将《毁灭战士》中移动的角色融入到借助 BSP 树绘制的静态关卡几何体中。由于《毁灭战士》中的敌人会移动，它们不能成为 BSP 树的一部分；BSP 树只适用于永不移动的几何体。因此，《毁灭战士》渲染器首先绘制静态关卡几何体，并记录已绘制的屏幕区域 (使用另一种内存高效的数据结构)。然后，它以从后到前 (back-to-front) 的顺序绘制敌人，并根据遮挡它们的屏幕区域进行裁剪。这个过程不如使用 BSP 树渲染那么优化，但由于通常可见的敌人数量少于关卡中的几何体数量，所以速度在这里不是一个大问题。

在《毁灭战士》中使用 BSP 树是一个巨大的成功。显然，Carmack 能够发现 BSP 树是他问题的完美解决方案，这非常了不起。但这算得上是*天才*之举吗？

Fabien Sanglard 在他关于《毁灭战士》游戏引擎的优秀著作中引用 John Romero 的话，称 Bruce Naylor 的论文《构建好的分割树》主要讨论的是如何使用 BSP 树从 3D 模型中剔除背面 (backfaces) [^6]。据 Romero 说，Carmack 认为这个算法仍然对《毁灭战士》有用，所以他着手实现了它。这种描述对 Carmack 来说相当赞美——它暗示了当其他人还在使用这项技术渲染静态场景时，他已经看到了 BSP 树在实时视频游戏中的潜力。在《毁灭战士大师》中也有一个类似的赞美故事：Kushner 暗示 Carmack 阅读了 Naylor 的论文，并自问：“如果能用 BSP 不仅创建一张 3D 图像，而是整个虚拟世界呢？” [^7]

这种说法忽略了 BSP 树的历史。当美国空军的研究人员首次意识到分割场景可能有助于加快渲染速度时，他们感兴趣的是加快*实时*渲染，因为他们毕竟是在尝试创建一个飞行模拟器。飞行模拟器的例子在 1980 年的 BSP 论文中再次出现。Fuchs、Kedem 和 Naylor 讨论了 BSP 树如何在飞行员反复练习在同一机场降落的飞行模拟器中发挥作用。由于机场几何体永不改变，BSP 树只需生成一次。显然，他们心中所想的是实时模拟。在论文的引言中，他们甚至通过讨论实时图形系统必须能够在至少 1/30 秒内创建图像来激发他们的研究。

因此，Carmack 并不是第一个想到在实时图形模拟中使用 BSP 树的人。当然，预见到 BSP 树可能以这种方式使用是一回事，而真正实现它又是另一回事。但即使在实现过程中，Carmack 可能也获得了比通常认为的更多的指导。至少截至本文撰写之时， [关于 BSP 树的维基百科页面](https://en.wikipedia.org/wiki/Binary_space_partitioning) 提到 Carmack 查阅了 Chen 和 Gordon 在 1991 年发表的一篇论文，以及一本名为《计算机图形学：原理与实践》(Computer Graphics: Principles and Practice) 的 1990 年教科书。尽管没有为这一说法提供引用，但这很可能是真的。1991 年 Chen 和 Gordon 的论文概述了一种使用 BSP 树的从前到后 (front-to-back) 渲染方法，这种方法与《毁灭战士》采用的方法基本相同，甚至包括我所说的“隐式 Z 缓冲区 (implicit z-buffer)”数据结构，该结构可以防止较远的多边形覆盖较近的多边形。这本教科书提供了 BSP 树的精彩概述，以及用于构建和显示树的一些伪代码 (pseudocode)。(多亏了我出色的大学图书馆，我得以快速浏览了 1990 年版。)《计算机图形学：原理与实践》是计算机图形学领域的经典教材，所以 Carmack 很可能拥有它。

尽管如此，Carmack 还是面临着一个新颖的问题——“我们如何让一款第一人称射击游戏在连浮点运算 (floating-point operations) 都无法执行的 CPU 上运行？”——他进行了研究，并证明了 BSP 树是实时视频游戏中有用的数据结构。我仍然认为这是一项令人印象深刻的壮举，即使 BSP 树早在十年前就被发明出来，并且在 Carmack 读到它的时候已经有了相当完善的理论。也许我们真正应该庆祝的成就是整个《毁灭战士》游戏引擎，它确实是一件非常巧妙的作品。我已经提到过一次，但 Fabien Sanglard 关于《毁灭战士》游戏引擎的书籍《游戏引擎黑皮书：毁灭战士》(Game Engine Black Book: DOOM) 对游戏引擎中所有不同的巧妙组件以及它们如何协同工作提供了出色的概述。我们不应该忘记，VSD 问题只是 Carmack 为了让《毁灭战士》引擎工作而必须解决的众多问题之一。他能够在所有其他工作之外，阅读并实现一个大多数程序员都不知道的复杂数据结构，这充分说明了他的技术专长以及他精益求精的动力。

*如果你喜欢这篇文章，每四周都会有更多类似的文章发布！请在 Twitter 上关注 [@TwoBitHistory](https://twitter.com/TwoBitHistory) 或订阅 [RSS 源](https://twobithistory.org/feed.xml)，以确保你不会错过新文章。*

*TwoBitHistory 往期回顾…*

> 我一直想更多地了解 GNU Readline，所以我想把它写成一篇新的博客文章。其中包括与维护 Readline (和 Bash) 的 Chet Ramey 的电子邮件交流中的一些有趣事实：<https://t.co/wnXeuyjgMx>
>
> — TwoBitHistory (@TwoBitHistory) [2019 年 8 月 22 日](https://twitter.com/TwoBitHistory/status/1164631020353859585?ref_src=twsrc%5Etfw)

[^1]: Michael Abrash, “Michael Abrash’s Graphics Programming Black Book,” James Gregory, accessed November 6, 2019, [http://www.jagregory.com/abrash-black-book/#chapter-64-quakes-visible-surface-determination](http://www.jagregory.com/abrash-black-book/#chapter-64-quakes-visible-surface-determination).
[^2]: R. Schumacher, B. Brand, M. Gilliland, W. Sharp, “Study for Applying Computer-Generated Images to Visual Simulation,” Air Force Human Resources Laboratory, December 1969, accessed on November 6, 2019, [https://apps.dtic.mil/dtic/tr/fulltext/u2/700375.pdf](https://apps.dtic.mil/dtic/tr/fulltext/u2/700375.pdf).
[^3]: Henry Fuchs, Zvi Kedem, Bruce Naylor, “On Visible Surface Generation By A Priori Tree Structures,” ACM SIGGRAPH Computer Graphics, July 1980.
[^4]: Fabien Sanglard, Game Engine Black Book: DOOM (CreateSpace Independent Publishing Platform, 2018), 200.
[^5]: Sanglard, 206.
[^6]: Sanglard, 200.
[^7]: David Kushner, Masters of Doom (Random House Trade Paperbacks, 2004), 142.