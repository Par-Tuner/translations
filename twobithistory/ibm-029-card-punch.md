# IBM 029 打卡机

*2018 年 6 月 23 日*

代码行超过 80 个字符总是让我抓狂。我知道这有点吹毛求疵。我在网上看到过一些很好的论点，解释了为什么即使在现代的 Retina 显示屏上，也应该遵守 80 字符的限制，但这些论点仍然无法平息我对哪怕是多出来的第 81 个字符那种发自内心的厌恶。

曾几何时，有一个黄金时代，那时代码行基本上不可能超过 80 个字符的限制。80 字符的限制是一个物理现实，因为根本没有第 81 列来容纳第 81 个字符。任何试图给函数起一个冗长又糟糕的名字的程序员，都会在一种美妙的、缓慢浮现的恐惧中发现，他们的整个声明根本没有空间容纳。

这个黄金时代就是穿孔卡片编程 (punch card programming) 的时代。到了 20 世纪 60 年代，IBM 的穿孔卡片已经设定了标准，而这个标准就是穿孔卡片有 80 列。80 列的标准一直延续到电传打字机 (teletype) 和哑终端时代，并从那时起深深地嵌入到我们操作系统的各个角落。如今，当你启动终端模拟器并打开一个新窗口时，它很可能就是 80 个字符宽，尽管我们现在有充足的屏幕空间，并且倾向于使用更长的标识符，而不是像 `iswcntrl()` 这样难以理解的无意义代码。

如果 Quora 上的问题能说明问题的话，很多人都难以想象用穿孔卡片编程计算机是什么样子。我承认，很长一段时间以来，我也不明白穿孔卡片编程是如何运作的，因为它在我看来打那些孔实在是太劳动密集型了。这是一个误解；程序员从来不像列车员那样在卡片上打孔。他们有打卡机 (card punch machines，也称为键控穿孔机 key punches)，这让他们可以使用打字机式键盘在卡片上打孔。而且打卡机绝非新技术——它们早在 19 世纪 90 年代就已经出现了。

最广泛使用的打卡机之一是 IBM 029。它也许是今天最广为人知的打卡机。

![](https://twobithistory.org/images/ibm029_front.jpg)

IBM 029 于 1964 年作为 IBM System/360 系列的推出的一部分发布。System/360 是一个计算机系统和外围设备系列，它将在 20 世纪 60 年代后期主导大型机计算市场。像许多其他 System/360 机器一样，029 体积庞大。这是一个计算设备和家具之间的界限模糊不清的时代——029 不是你放在桌子上的东西，它本身就是一张完整的桌子。029 在其前身 026 的基础上进行了改进，支持括号等新字符，并且整体上更安静。它有炫酷的电蓝色点缀，扁平且棱角分明，而 026 则具有 20 世纪 40 年代那种圆润的工业外观。它的另一个主要卖点是它可以自动用零左填充数字字段，这表明 JavaScript 程序员并不是第一批懒得自己进行左填充的程序员。

但是等等，你可能会说——IBM 在 1964 年发布了一款全新的打卡机？那贝尔实验室 (Bell Labs) 的 Unix 大神们在 1970 年左右使用电传打字机的照片是怎么回事？难道打卡机在 20 世纪 60 年代中后期就已经过时了吗？嗯，你可能会惊讶地发现，029 在 IBM 的产品目录中一直销售到 1984 年。[^1] 事实上，大多数程序员直到 20 世纪 70 年代中期都还在使用穿孔卡片编程。考虑到第二次世界大战期间就有人使用电传打字机，这似乎说不通。确实，电传打字机几乎与打卡机同时代。事实证明，限制因素不是电传打字机的可用性，而是计算时间的可用性。阻碍人们使用电传打字机的原因是，电传打字机假定了一种与计算机交互的“在线”通信模式。在 Unix 和分时操作系统 (timesharing operating systems) 发明之前，你与计算机的交互会话会阻止其他人使用它，这种延迟可能造成数千美元的损失。因此，程序员们转而使用打卡机离线编写程序，然后将它们作为批处理作业 (batch jobs) 稍后输入到大型机中。穿孔卡片还有一个额外的好处，那就是在一个廉价可靠的数据存储难以获得的时代，它是一种廉价的数据存储方式。你的程序以一叠叠卡片的形式存放在你的书架上，而不是以文件的形式存放在你的硬盘上。

那么，使用 IBM 029 打卡机到底是什么样的体验呢？这很难解释，除非我们先看看卡片本身。一张典型的穿孔卡片有 12 行 80 列。最下面的九行是数字行，编号从一到九。这些行在每列都印有相应的数字。最上面的三行，称为“区段行 (zone rows)”，由两行空白行和通常一行零行组成。第 12 行在卡片的最顶部，其次是第 11 行，然后是第零行到第九行。这种有些令人困惑的顺序意味着卡片的上边缘被称为 12 边，而下边缘被称为 9 边。每张卡片的一个角通常会被剪掉，以便更容易地确保一叠卡片方向一致。

![](https://twobithistory.org/images/card.png)

穿孔卡片最初发明时，是为了打圆形孔，但 IBM 最终意识到，如果孔是狭窄的矩形，他们可以在一张卡片上容纳更多的列。一列中不同的孔组合代表不同的字符。为了方便人类使用，像 029 这样的打卡机在打出必要的孔的同时，也会在卡片顶部打印出每列对应的字符。数字通过在相应的数字行打一个孔来表示。字母和符号字符则通过在区段行打一个孔，然后在数字行打一个或两个孔的组合来表示。例如，字母 A 通过在 12 区段行打一个孔和在 1 行打另一个孔来表示。这是一种编码，有时被称为霍勒里斯码 (Hollerith code)，以穿孔卡片机的最初发明者命名。这种编码只允许使用相对较小的字符集；例如，小写字母就没有表示。今天的一些聪明工程师可能会想，为什么穿孔卡片不直接使用二进制编码 (binary encoding)——毕竟，有 12 行，你可以编码超过 4000 个字符。霍勒里斯码之所以被使用，是因为它确保了单列中最多只出现三个孔。这保留了卡片的结构完整性。二进制编码会涉及太多的孔，以至于卡片会散架。

卡片有不同类型。到了 20 世纪 60 年代，80 列是标准，但这 80 列可以用来表示不同的东西。基本的穿孔卡片是未标记的，但例如用于 COBOL 编程的卡片，则将 80 列划分为不同的字段。在 COBOL 卡片上，最后八列保留用于识别号，如果卡片掉落 (显然这是一个长期存在的风险)，可以使用它来自动对一叠卡片进行排序。另一列，即第七列，可以用来指示这张卡片上的语句是前一张卡片上语句的延续。这意味着如果你真的走投无路，你 *可以* 规避 80 字符限制，尽管两张卡片的语句是算作一行长代码还是仅仅两行尚不清楚。FORTRAN 卡片类似，但有不同的字段。大学通常会在其计算中心分发的穿孔卡片上印上水印，而其他类型的图案则用于特殊场合，如 1976 年美国建国二百周年纪念日。

最终，这些卡片必须由计算机读取和理解。IBM 销售了一款名为 IBM 2540 的 System/360 外围设备，它每分钟可以读取多达 1000 张卡片。[^2] IBM 2540 通过电刷在每张卡片的表面滑动，在有孔的地方与卡片后面的金属板接触。一旦读取，System/360 系列计算机使用一种名为 EBCDIC 的 8 位编码来表示每张穿孔卡片上的字符，EBCDIC 代表扩展二进制编码十进制交换码 (Extended Binary Coded Decimal Interchange Code)。EBCDIC 是一种真正的二进制编码，但它仍然通过一种名为 BCDIC 的早期编码追溯其根源到穿孔卡片，BCDIC 是一种 6 位编码，它使用低四位来表示穿孔卡片的数字行，高两位来表示区段行。穿孔卡片程序员通常会将他们的卡片交给实际的计算机操作员，操作员会将卡片送入 IBM 2540，然后将打印结果交还给程序员。程序员通常根本看不到计算机。

程序员经常看到的是打卡机。029 不是一台计算机，但这并不意味着它不是一台复杂的机器。了解使用 029 是什么感觉的最好方法是观看密歇根大学 (University of Michigan) 计算中心在 1967 年制作的 [这个教学视频](https://www.youtube.com/watch?v=kaQmAybWn-w)。我将尽力在这里总结它，但如果你不看视频，你将错过所有美妙的咔嗒声和呼啸声。

029 是围绕一个 U 形轨道建造的，穿孔卡片沿着这个轨道移动。在右侧，U 形轨道的顶部，是卡片进料斗 (card hopper)，你通常在使用机器前会在这里装入一叠新卡片。IBM 029 主要处理 80 列卡片，但卡片进料斗也可以容纳较小的卡片。你的穿孔卡片会从卡片进料斗开始，沿着 U 形轨道移动，然后最终进入堆叠器 (stacker)，位于 U 形轨道的左侧顶部。卡片会按照你打孔的顺序堆叠在那里。

要打开机器，你需要拨动桌子下面大约膝盖高度的一个开关。然后你按两次“FEED”键，将卡片装入机器。卡片轨道的关键部分，即 U 形轨道的底部，由三个独立的工位组成：右侧是一个等待区，中间是打孔站 (punching station)，左侧是读取站 (reading station)。按两次“FEED”键会将一张卡片装入打孔站，另一张卡片装入其后面的等待区。打孔站正上方的一个列号指示器会告诉你当前正在打哪一列。每按一次键，机器就会打出所需的孔，在卡片顶部打印出相应的字符，然后将卡片在打孔站向前推进一列。如果你打满了 80 列，卡片会自动释放到读取站，一张新卡片会装入打孔站。如果你想在达到第 80 列之前就发生这种情况，你可以按“REL”键 (表示“释放”)。

打印的字符使得发现错误变得容易。但是，正如密歇根大学的视频所警告的那样，纠正错误并不像涂改卡片顶部打印的字符并写上新字符那么容易。计算机只读取孔。也不像退格一格并输入新字符那么容易。毕竟，孔已经打在列中了，无法取消打孔。打更多的孔只会产生无效的组合，不与任何字符关联。IBM 029 确实有一个退格按钮，可以将打孔卡片向后移动一列，但该按钮放置在机器面板上而不是键盘上。这可能是为了不鼓励使用它，因为退格很少是用户真正想做的。

相反，纠正错误的唯一方法是废弃错误的卡片并打一张新卡片。这就是读取站派上用场的地方。假设你在卡片的第 68 列犯了一个错误。要纠正你的错误，你可以小心地在新卡片上重新打前 67 列，然后在第 68 列打上正确的字符。或者，你可以将错误的卡片释放到读取站，将一张新卡片装入打孔站，然后按住“DUP”键 (表示“复制”)，直到列号指示器显示 68。然后你就可以通过打上正确的字符来纠正你的错误。读取站和“DUP”键一起，使得 IBM 029 的操作员可以轻松地将一张卡片的内容复制到下一张。这样做有各种各样的原因，但纠正错误是最常见的。

“DUP”键允许 029 的操作员手动调用复制功能。但 029 也可以在必要时自动复制。当穿孔卡片用于记录数据而不是程序时，这尤其有用。例如，你可能使用每张卡片来记录一个大学本科生的信息。在每张卡片上，你可能有一个字段包含该学生的学生宿舍名称。也许你发现自己一次性输入一个学生宿舍所有学生的数据。在这种情况下，你希望 029 在每次到达该字段的第一列时，自动复制上一张卡片的学生宿舍字段。

像这样的自动化行为可以通过使用程序鼓 (program drum) 编程到 029 中。程序鼓直立在 U 形轨道的中间，位于打孔站上方。你通过在一张卡片上打孔，然后将这张卡片缠绕在程序鼓上来编程 029。这张打孔卡片允许你指定机器在当前打孔站中的卡片的每一列所期望的自动行为。你可以指定某一列应该自动从上一张卡片复制，这就是 029 操作员可以更快地输入学生记录的方式。你还可以指定，例如，某个特定字段应该包含数字或字母字符，或者某个给定字段应该留空并完全跳过。程序鼓使得打孔格式化卡片 (schematized cards) 变得容易得多，在这些卡片中，某些列范围具有特殊含义。密歇根大学还制作了另一个介绍程序鼓的 [“高级”教学视频](https://www.youtube.com/watch?v=SWD1PwNxpoU)，如果你已经掌握了基础知识，这个视频值得一看。

今天观看密歇根大学的任何一个视频，令人惊讶的是打卡机操作起来多么容易。纠正错误很繁琐，但除此之外，这台机器似乎比我预期的障碍要小。从一张卡片到下一张卡片的过渡是如此无缝，以至于我可以想象 COBOL 或 FORTRAN 程序员会忘记他们正在创建的是单独的卡片，而不是一个长的连续文本文件。另一方面，有趣的是，即使打卡机只是一种输入工具，它也可能限制了早期编程语言的演变方式。结构化编程 (Structured programming) 最终会出现并鼓励人们将整个代码块视为一个单元，但我可以看到穿孔卡片编程对每一行的强调使得结构化编程难以想象。难怪穿孔卡片程序员不是那些决定用单独的、完全占据一行的花括号来包围代码块的人。那看起来会多么浪费啊！

所以，尽管现在没有人再使用穿孔卡片编程了，但每个程序员都应该 [尝试一下](http://www.masswerk.at/keypunch/) 至少一次——哪怕只是为了理解 COBOL 和 FORTRAN 之所以是现在这个样子，或者 80 字符不知何故成了大家最喜欢的字符限制。

*如果您喜欢这篇文章，每四周会发布更多类似的文章！在 Twitter 上关注 [@TwoBitHistory](https://twitter.com/TwoBitHistory) 或订阅 [RSS 源](https://twobithistory.org/feed.xml)，确保您能及时了解新文章的发布。*

[^1]: “IBM 29 打卡机”，IBM 档案，2018 年 6 月 23 日访问，[https://www-03.ibm.com/ibm/history/exhibits/vintage/vintage_4506VV4002.html](https://www-03.ibm.com/ibm/history/exhibits/vintage/vintage_4506VV4002.html)。
[^2]: IBM，《IBM 2540 组件描述与操作规程》 (明尼苏达州罗切斯特：IBM 产品出版物，1965 年)，2009 年 9 月 6 日，2018 年 6 月 23 日访问，[http://bitsavers.informatik.uni-stuttgart.de/pdf/ibm/25xx/A21-9033-1_2540_Card_Punch_Component_Description_1965.pdf](http://bitsavers.informatik.uni-stuttgart.de/pdf/ibm/25xx/A21-9033-1_2540_Card_Punch_Component_Description_1965.pdf)。